<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Browser Meltdown - Simple</title>
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        
        #control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 280px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 20px;
            cursor: move;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            user-select: none;
        }
        
        #control-panel.dragging {
            opacity: 0.8;
            cursor: grabbing;
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .panel-title {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            margin: 0;
        }
        
        .minimize-btn {
            background: none;
            border: none;
            color: #999;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .minimize-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-label {
            font-size: 13px;
            font-weight: 500;
            color: #aaa;
            margin-bottom: 8px;
            display: block;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 100%;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: relative;
            display: block;
            width: 100%;
            height: 36px;
            background: #333;
            border-radius: 18px;
            cursor: pointer;
            transition: 0.3s;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: '';
            height: 28px;
            width: 50%;
            left: 4px;
            top: 4px;
            background: #666;
            border-radius: 50%;
            transition: 0.3s;
        }
        
        input:checked + .toggle-slider {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(100%);
            background: #fff;
        }
        
        .toggle-labels {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 12px;
            align-items: center;
            font-size: 12px;
            font-weight: 600;
            pointer-events: none;
        }
        
        .toggle-label {
            color: #999;
            transition: 0.3s;
        }
        
        input:checked ~ .toggle-labels .toggle-label.cpu {
            color: #999;
        }
        
        input:checked ~ .toggle-labels .toggle-label.gpu {
            color: #fff;
        }
        
        input:not(:checked) ~ .toggle-labels .toggle-label.cpu {
            color: #fff;
        }
        
        input:not(:checked) ~ .toggle-labels .toggle-label.gpu {
            color: #999;
        }
        
        .intensity-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        
        .intensity-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.5);
        }
        
        .intensity-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.5);
        }
        
        .intensity-value {
            font-size: 13px;
            color: #667eea;
            font-weight: 600;
            margin-top: 4px;
        }
        
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat-item {
            text-align: center;
        }
        
        .stat-label {
            font-size: 11px;
            color: #666;
            margin-bottom: 4px;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: 600;
            color: #fff;
        }
        
        .stat-unit {
            font-size: 12px;
            color: #666;
            font-weight: 400;
        }
        
        #fps {
            color: #667eea;
        }
        
        #load-indicator {
            color: #f093fb;
        }
        
        .collapsed {
            position: absolute;
            top: 20px;
            right: 20px;
            width: auto;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            cursor: pointer;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none;
        }
        
        .collapsed:hover {
            background: rgba(0, 0, 0, 0.9);
        }
        
        .collapsed-text {
            font-size: 13px;
            font-weight: 500;
            color: #fff;
        }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
</head>
<body>
    <div id="control-panel">
        <div class="panel-header">
            <h1 class="panel-title">Browser Meltdown</h1>
            <button class="minimize-btn" id="minimize-btn">−</button>
        </div>
        
        <div class="control-group">
            <label class="control-label">Processing Mode</label>
            <div class="toggle-switch">
                <input type="checkbox" id="mode-toggle" checked>
                <span class="toggle-slider"></span>
                <div class="toggle-labels">
                    <span class="toggle-label cpu">CPU</span>
                    <span class="toggle-label gpu">GPU</span>
                </div>
            </div>
        </div>
        
        <div class="control-group">
            <label class="control-label" for="intensity-slider">Intensity</label>
            <input type="range" id="intensity-slider" class="intensity-slider" min="0" max="100" value="50">
            <div class="intensity-value"><span id="intensity-value">50</span>%</div>
        </div>
        
        <div class="stats">
            <div class="stat-item">
                <div class="stat-label">FPS</div>
                <div class="stat-value" id="fps">60</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Load</div>
                <div class="stat-value" id="load-indicator">50<span class="stat-unit">%</span></div>
            </div>
        </div>
    </div>
    
    <div class="collapsed" id="collapsed-panel">
        <span class="collapsed-text">☢️ Browser Meltdown</span>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            mode: 'gpu', // 'cpu' or 'gpu'
            intensity: 50,
            radius: 30
        };

        // ============================================
        // SCENE SETUP
        // ============================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.z = 100;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0x667eea, 1, 100);
        pointLight1.position.set(50, 50, 50);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xf093fb, 0.8, 100);
        pointLight2.position.set(-50, -50, 30);
        scene.add(pointLight2);

        // ============================================
        // SHADERS
        // ============================================
        const vertexShader = `
            uniform float uTime;
            uniform float uIntensity;
            uniform vec2 uInput;
            varying float vDisplacement;
            varying vec3 vNormal;
            varying vec3 vPosition;
            
            void main() {
                vNormal = normal;
                vPosition = position;
                
                // Complex vertex deformation
                float displacement = 0.0;
                
                // Multi-layered deformation based on intensity
                float intensity = uIntensity / 100.0;
                
                displacement += sin(position.x * (0.02 + intensity * 0.08) + uTime + uInput.x) * (5.0 + intensity * 10.0);
                displacement += cos(position.y * (0.02 + intensity * 0.06) + uTime * 1.3 + uInput.y) * (3.0 + intensity * 8.0);
                displacement += sin(position.z * (0.03 + intensity * 0.05) + uTime * 0.7) * (4.0 + intensity * 6.0);
                
                // Add noise-based displacement for higher intensity
                if (intensity > 0.3) {
                    displacement += sin(position.x * 0.1 + uTime * 2.0) * cos(position.y * 0.1 + uTime * 1.5) * sin(position.z * 0.1 + uTime * 1.8) * (intensity - 0.3) * 15.0;
                }
                
                vec3 newPosition = position + normal * displacement;
                vDisplacement = displacement;
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
            }
        `;

        const fragmentShader = `
            uniform vec3 uColorLow;
            uniform vec3 uColorHigh;
            uniform float uTime;
            uniform float uIntensity;
            varying float vDisplacement;
            varying vec3 vNormal;
            varying vec3 vPosition;
            
            void main() {
                float intensity = uIntensity / 100.0;
                float t = smoothstep(-20.0, 20.0, vDisplacement);
                
                // Color gradient based on displacement
                vec3 color = mix(uColorLow, uColorHigh, t);
                
                // Rim lighting
                vec3 viewDir = normalize(cameraPosition - vPosition);
                float rim = 1.0 - max(dot(vNormal, viewDir), 0.0);
                rim = pow(rim, 2.0);
                color += vec3(0.2, 0.1, 0.3) * rim;
                
                // Pulse effect
                float pulse = sin(uTime * (1.0 + intensity * 2.0)) * 0.5 + 0.5;
                color += vec3(0.1, 0.05, 0.15) * pulse * intensity;
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // ============================================
        // GEOMETRY & MATERIALS
        // ============================================
        let geometry;
        let material;
        let sphere;
        let basePositions;

        function createSphere() {
            // Cleanup old geometry
            if (sphere) {
                scene.remove(sphere);
                geometry.dispose();
                material.dispose();
            }

            // Create new geometry based on intensity
            const detail = Math.floor(20 + (CONFIG.intensity / 100) * 60); // 20 to 80
            const radius = CONFIG.radius;
            
            geometry = new THREE.SphereGeometry(radius, detail, detail);
            basePositions = Float32Array.from(geometry.attributes.position.array);

            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uIntensity: { value: CONFIG.intensity },
                    uInput: { value: new THREE.Vector2(0, 0) },
                    uColorLow: { value: new THREE.Color(0x2196F3) }, // Blue
                    uColorHigh: { value: new THREE.Color(0xFF4081) } // Pink
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                wireframe: CONFIG.intensity > 70
            });

            sphere = new THREE.Mesh(geometry, material);
            scene.add(sphere);
        }

        // ============================================
        // CPU DEFORMATION
        // ============================================
        function updateCPU(time) {
            if (CONFIG.mode !== 'cpu') return;

            const positions = geometry.attributes.position.array;
            const normals = geometry.attributes.normal.array;
            const count = geometry.attributes.position.count;
            
            const intensity = CONFIG.intensity / 100.0;

            for (let i = 0; i < count; i++) {
                const ix = i * 3, iy = i * 3 + 1, iz = i * 3 + 2;
                const bx = basePositions[ix], by = basePositions[iy], bz = basePositions[iz];
                const nx = normals[ix], ny = normals[iy], nz = normals[iz];
                
                // Complex calculation that stresses the CPU
                let displacement = 0.0;
                displacement += Math.sin(bx * (0.02 + intensity * 0.08) + time) * (5.0 + intensity * 10.0);
                displacement += Math.cos(by * (0.02 + intensity * 0.06) + time * 1.3) * (3.0 + intensity * 8.0);
                displacement += Math.sin(bz * (0.03 + intensity * 0.05) + time * 0.7) * (4.0 + intensity * 6.0);
                
                if (intensity > 0.3) {
                    displacement += Math.sin(bx * 0.1 + time * 2.0) * Math.cos(by * 0.1 + time * 1.5) * Math.sin(bz * 0.1 + time * 1.8) * (intensity - 0.3) * 15.0;
                }
                
                positions[ix] = bx + (nx * displacement);
                positions[iy] = by + (ny * displacement);
                positions[iz] = bz + (nz * displacement);
            }
            
            geometry.attributes.position.needsUpdate = true;
        }

        // ============================================
        // UI CONTROLS
        // ============================================
        const modeToggle = document.getElementById('mode-toggle');
        const intensitySlider = document.getElementById('intensity-slider');
        const intensityValue = document.getElementById('intensity-value');
        const fpsEl = document.getElementById('fps');
        const loadEl = document.getElementById('load-indicator');
        const controlPanel = document.getElementById('control-panel');
        const collapsedPanel = document.getElementById('collapsed-panel');
        const minimizeBtn = document.getElementById('minimize-btn');

        // Mode toggle
        modeToggle.addEventListener('change', (e) => {
            CONFIG.mode = e.target.checked ? 'gpu' : 'cpu';
            // GPU mode uses shaders, CPU mode uses JavaScript
            if (CONFIG.mode === 'gpu') {
                material.wireframe = false;
            }
        });

        // Intensity slider
        intensitySlider.addEventListener('input', (e) => {
            CONFIG.intensity = parseInt(e.target.value);
            intensityValue.textContent = CONFIG.intensity;
            loadEl.textContent = CONFIG.intensity;
            createSphere(); // Recreate geometry with new detail level
        });

        // Draggable panel
        let isDragging = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        controlPanel.addEventListener('mousedown', (e) => {
            if (e.target.closest('.minimize-btn')) return;
            
            isDragging = true;
            dragOffsetX = e.clientX - controlPanel.offsetLeft;
            dragOffsetY = e.clientY - controlPanel.offsetTop;
            controlPanel.classList.add('dragging');
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const x = e.clientX - dragOffsetX;
            const y = e.clientY - dragOffsetY;
            
            // Constrain to viewport
            const maxX = window.innerWidth - controlPanel.offsetWidth;
            const maxY = window.innerHeight - controlPanel.offsetHeight;
            
            controlPanel.style.left = Math.max(0, Math.min(x, maxX)) + 'px';
            controlPanel.style.top = Math.max(0, Math.min(y, maxY)) + 'px';
            controlPanel.style.right = 'auto';
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            controlPanel.classList.remove('dragging');
        });

        // Minimize/expand
        minimizeBtn.addEventListener('click', () => {
            controlPanel.style.display = 'none';
            collapsedPanel.style.display = 'block';
        });

        collapsedPanel.addEventListener('click', () => {
            collapsedPanel.style.display = 'none';
            controlPanel.style.display = 'block';
        });

        // Input handling
        let inputVector = new THREE.Vector2(0, 0);

        window.addEventListener('mousemove', (e) => {
            inputVector.x = (e.clientX / window.innerWidth - 0.5) * 2;
            inputVector.y = (e.clientY / window.innerHeight - 0.5) * 2;
        });

        window.addEventListener('deviceorientation', (e) => {
            if (e.beta) {
                inputVector.y = e.beta / 30;
                inputVector.x = e.gamma / 30;
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ============================================
        // ANIMATION LOOP
        // ============================================
        let TIME = 0;
        let lastTime = performance.now();
        let frames = 0;

        function animate() {
            requestAnimationFrame(animate);
            TIME += 0.016; // ~60fps

            controls.update();

            // Update deformation
            if (CONFIG.mode === 'cpu') {
                updateCPU(TIME);
            } else {
                material.uniforms.uTime.value = TIME;
                material.uniforms.uIntensity.value = CONFIG.intensity;
                material.uniforms.uInput.value.copy(inputVector);
            }

            // Rotate sphere
            if (sphere) {
                sphere.rotation.y += 0.005;
                sphere.rotation.x += 0.002;
            }

            // FPS counter
            frames++;
            if (performance.now() - lastTime >= 1000) {
                fpsEl.textContent = frames;
                frames = 0;
                lastTime = performance.now();
            }

            renderer.render(scene, camera);
        }

        // ============================================
        // INITIALIZE
        // ============================================
        createSphere();
        animate();
    </script>
</body>
</html>